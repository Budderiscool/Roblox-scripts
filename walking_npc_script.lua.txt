-- Individual NPC Walking Script for Roblox
-- Place this script inside an NPC model as a Server Script
-- Make sure you have a folder called "NPCPoints" in workspace with parts as waypoints

local RunService = game:GetService("RunService")
local PathfindingService = game:GetService("PathfindingService")
local Players = game:GetService("Players")
local Debris = game:GetService("Debris")

-- Configuration
local NPC_CONFIG = {
    WalkSpeed = 8,
    RunSpeed = 16,
    FleeDistance = 50,
    ReturnDelay = 3,
    PathUpdateInterval = 2,
    WaypointTolerance = 4,
    MaxPathfindingRetries = 3,
    -- Player memory and avoidance
    MemoryDuration = 300, -- How long NPCs remember players (seconds)
    AvoidanceDistance = 25, -- Distance to maintain from remembered threats
    AvoidanceStrength = 1.5, -- How much to bend path away from threats
    -- Waypoint settings
    NPCPointsFolderName = "NPCPoints", -- Name of folder containing waypoint parts
    RandomWaypoints = true -- If true, chooses random waypoints; if false, follows in order
}

-- Get the NPC character (the model this script is inside)
local character = script.Parent
local humanoid = character:WaitForChild("Humanoid", 10)
local rootPart = character:WaitForChild("HumanoidRootPart", 10)

if not humanoid or not rootPart then
    error("This script must be placed inside an NPC model with Humanoid and HumanoidRootPart!")
end

-- NPC Class
local NPC = {}
NPC.__index = NPC

function NPC.new(character, config)
    local self = setmetatable({}, NPC)
    
    self.Character = character
    self.Humanoid = character:FindFirstChild("Humanoid")
    self.RootPart = character:FindFirstChild("HumanoidRootPart")
    
    if not self.Humanoid or not self.RootPart then
        warn("Failed to find Humanoid or HumanoidRootPart in " .. character.Name)
        return nil
    end
    
    self.Config = config or NPC_CONFIG
    
    -- State management
    self.State = "Wandering" -- "Wandering", "Fleeing", "Returning"
    self.OriginalPosition = self.RootPart.Position
    self.CurrentPath = nil
    self.CurrentWaypointIndex = 1
    self.LastPathUpdate = 0
    self.FleeStartTime = 0
    self.ThreatPlayer = nil
    
    -- Player memory system
    self.RememberedThreats = {} -- {playerName = {lastSeen = tick(), dangerLevel = number}}
    
    -- Pathfinding setup
    self.PathfindingAgent = {
        AgentRadius = 2,
        AgentHeight = 5,
        AgentCanJump = true,
        WaypointSpacing = 4
    }
    
    -- Setup waypoints from NPCPoints folder
    self:SetupWaypoints()
    
    -- Setup injury detection
    self:SetupInjuryDetection()
    
    -- Start the main loop
    self:StartMainLoop()
    
    return self
end

function NPC:SetupWaypoints()
    -- Find NPCPoints folder
    local npcPointsFolder = workspace:FindFirstChild(self.Config.NPCPointsFolderName)
    
    if not npcPointsFolder then
        warn("NPCPoints folder not found in workspace! Creating example waypoints around NPC spawn.")
        self:CreateFallbackWaypoints()
        return
    end
    
    -- Get all parts from NPCPoints folder
    self.WaypointParts = {}
    for _, child in pairs(npcPointsFolder:GetChildren()) do
        if child:IsA("BasePart") then
            table.insert(self.WaypointParts, child)
        end
    end
    
    if #self.WaypointParts == 0 then
        warn("No parts found in NPCPoints folder! Creating fallback waypoints.")
        self:CreateFallbackWaypoints()
        return
    end
    
    print(self.Character.Name .. " found " .. #self.WaypointParts .. " waypoints in " .. self.Config.NPCPointsFolderName)
    
    -- Sort waypoints by name if not using random waypoints
    if not self.Config.RandomWaypoints then
        table.sort(self.WaypointParts, function(a, b)
            return a.Name < b.Name
        end)
    end
end

function NPC:CreateFallbackWaypoints()
    -- Create waypoints around the NPC's spawn position
    local center = self.OriginalPosition
    self.FallbackWaypoints = {
        center + Vector3.new(20, 0, 0),
        center + Vector3.new(0, 0, 20),
        center + Vector3.new(-20, 0, 0),
        center + Vector3.new(0, 0, -20),
        center + Vector3.new(15, 0, 15),
        center + Vector3.new(-15, 0, 15),
        center + Vector3.new(-15, 0, -15),
        center + Vector3.new(15, 0, -15)
    }
    self.CurrentWaypointIndex = 1
    print(self.Character.Name .. " using fallback waypoints around spawn position")
end

function NPC:SetupInjuryDetection()
    -- Detect when NPC takes damage
    self.Humanoid.HealthChanged:Connect(function(health)
        if health < self.Humanoid.MaxHealth and health > 0 then
            self:OnInjured()
        end
    end)
    
    -- Also detect when hit by tools/weapons
    self.Character.ChildAdded:Connect(function(child)
        if child:IsA("Tool") then
            self:OnInjured()
        end
    end)
end

function NPC:OnInjured()
    if self.State == "Fleeing" then return end
    
    -- Find the closest player as the threat
    local closestPlayer = self:FindClosestPlayer()
    if closestPlayer then
        -- Remember this player as a threat
        self:RememberThreat(closestPlayer)
        
        self.ThreatPlayer = closestPlayer
        self.State = "Fleeing"
        self.FleeStartTime = tick()
        self.Humanoid.WalkSpeed = self.Config.RunSpeed
        
        -- Create a visual effect
        self:CreateFleeEffect()
        
        print(self.Character.Name .. " was hurt by " .. closestPlayer.Name .. " and is now fleeing!")
    end
end

function NPC:FindClosestPlayer()
    local closestPlayer = nil
    local closestDistance = math.huge
    
    for _, player in pairs(Players:GetPlayers()) do
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local distance = (player.Character.HumanoidRootPart.Position - self.RootPart.Position).Magnitude
            if distance < closestDistance then
                closestDistance = distance
                closestPlayer = player
            end
        end
    end
    
    return closestPlayer
end

function NPC:CreateFleeEffect()
    -- Create a red sphere above NPC's head to indicate fear
    local effect = Instance.new("Part")
    effect.Name = "FleeEffect"
    effect.Size = Vector3.new(1, 1, 1)
    effect.Shape = Enum.PartType.Ball
    effect.Color = Color3.new(1, 0, 0)
    effect.Material = Enum.Material.Neon
    effect.CanCollide = false
    effect.Anchored = true
    effect.Parent = workspace
    
    local head = self.Character:FindFirstChild("Head")
    if head then
        local weld = Instance.new("WeldConstraint")
        weld.Part0 = effect
        weld.Part1 = head
        weld.Parent = effect
        effect.CFrame = head.CFrame + Vector3.new(0, 2, 0)
    end
    
    Debris:AddItem(effect, 3)
end

function NPC:RememberThreat(player)
    local playerName = player.Name
    if not self.RememberedThreats[playerName] then
        self.RememberedThreats[playerName] = {
            lastSeen = tick(),
            dangerLevel = 1,
            player = player
        }
    else
        -- Increase danger level for repeat offenders
        self.RememberedThreats[playerName].dangerLevel = self.RememberedThreats[playerName].dangerLevel + 1
        self.RememberedThreats[playerName].lastSeen = tick()
        self.RememberedThreats[playerName].player = player
    end
    
    print(self.Character.Name .. " now remembers " .. playerName .. " as a threat (Danger Level: " .. 
          self.RememberedThreats[playerName].dangerLevel .. ")")
end

function NPC:ForgetOldThreats()
    local currentTime = tick()
    for playerName, threatData in pairs(self.RememberedThreats) do
        if currentTime - threatData.lastSeen > self.Config.MemoryDuration then
            self.RememberedThreats[playerName] = nil
        end
    end
end

function NPC:GetNearbyThreats()
    local nearbyThreats = {}
    
    for playerName, threatData in pairs(self.RememberedThreats) do
        if threatData.player and threatData.player.Character and 
           threatData.player.Character:FindFirstChild("HumanoidRootPart") then
            
            local distance = (threatData.player.Character.HumanoidRootPart.Position - self.RootPart.Position).Magnitude
            if distance <= self.Config.AvoidanceDistance then
                table.insert(nearbyThreats, {
                    player = threatData.player,
                    distance = distance,
                    dangerLevel = threatData.dangerLevel,
                    position = threatData.player.Character.HumanoidRootPart.Position
                })
            end
        end
    end
    
    return nearbyThreats
end

function NPC:GetAvoidanceAdjustedDestination(originalDestination)
    local threats = self:GetNearbyThreats()
    if #threats == 0 then
        return originalDestination
    end
    
    local avoidanceVector = Vector3.new(0, 0, 0)
    local myPos = self.RootPart.Position
    
    -- Calculate avoidance vector based on all nearby threats
    for _, threat in ipairs(threats) do
        local threatPos = threat.position
        local directionAway = (myPos - threatPos).Unit
        local influence = (self.Config.AvoidanceDistance - threat.distance) / self.Config.AvoidanceDistance
        influence = influence * threat.dangerLevel * self.Config.AvoidanceStrength
        
        avoidanceVector = avoidanceVector + (directionAway * influence * 20)
    end
    
    -- Apply avoidance to destination
    local adjustedDestination = originalDestination + avoidanceVector
    
    -- Make sure the adjusted destination is still reasonable (not too far off course)
    local maxDeviation = 30
    local deviation = (adjustedDestination - originalDestination).Magnitude
    if deviation > maxDeviation then
        local deviationDirection = (adjustedDestination - originalDestination).Unit
        adjustedDestination = originalDestination + (deviationDirection * maxDeviation)
    end
    
    return adjustedDestination
end

function NPC:GetFleeDestination()
    if not self.ThreatPlayer or not self.ThreatPlayer.Character then
        return self.OriginalPosition
    end
    
    local threatPos = self.ThreatPlayer.Character.HumanoidRootPart.Position
    local myPos = self.RootPart.Position
    local fleeDirection = (myPos - threatPos).Unit
    
    -- Flee further away from players with higher danger levels
    local dangerMultiplier = 1
    if self.RememberedThreats[self.ThreatPlayer.Name] then
        dangerMultiplier = self.RememberedThreats[self.ThreatPlayer.Name].dangerLevel
    end
    
    local fleeDistance = self.Config.FleeDistance * dangerMultiplier
    return myPos + fleeDirection * fleeDistance
end

function NPC:CreatePath(destination)
    local path = PathfindingService:CreatePath(self.PathfindingAgent)
    local success, errorMessage = pcall(function()
        path:ComputeAsync(self.RootPart.Position, destination)
    end)
    
    if success and path.Status == Enum.PathStatus.Success then
        return path
    else
        return nil
    end
end

function NPC:FollowPath(path)
    if not path then return end
    
    local waypoints = path:GetWaypoints()
    if #waypoints < 2 then return end
    
    self.Humanoid:MoveTo(waypoints[2].Position) -- Skip first waypoint (current position)
    
    -- Handle waypoint reached
    local connection
    connection = self.Humanoid.MoveToFinished:Connect(function(reached)
        if reached and #waypoints > 2 then
            table.remove(waypoints, 1)
            if #waypoints > 1 then
                self.Humanoid:MoveTo(waypoints[2].Position)
            else
                connection:Disconnect()
            end
        else
            connection:Disconnect()
        end
    end)
end

function NPC:GetNextWaypoint()
    -- Check if we have waypoint parts from NPCPoints folder
    if self.WaypointParts and #self.WaypointParts > 0 then
        if self.Config.RandomWaypoints then
            -- Choose a random waypoint
            local randomPart = self.WaypointParts[math.random(1, #self.WaypointParts)]
            return randomPart.Position
        else
            -- Follow waypoints in order
            local waypoint = self.WaypointParts[self.CurrentWaypointIndex]
            self.CurrentWaypointIndex = self.CurrentWaypointIndex + 1
            if self.CurrentWaypointIndex > #self.WaypointParts then
                self.CurrentWaypointIndex = 1
            end
            return waypoint.Position
        end
    elseif self.FallbackWaypoints then
        -- Use fallback waypoints if NPCPoints folder wasn't found
        local waypoint = self.FallbackWaypoints[self.CurrentWaypointIndex]
        self.CurrentWaypointIndex = self.CurrentWaypointIndex + 1
        if self.CurrentWaypointIndex > #self.FallbackWaypoints then
            self.CurrentWaypointIndex = 1
        end
        return waypoint
    else
        -- Last resort: return to original position
        return self.OriginalPosition
    end
end

function NPC:UpdateWandering()
    -- Clean up old threat memories
    self:ForgetOldThreats()
    
    local currentTime = tick()
    if currentTime - self.LastPathUpdate > self.Config.PathUpdateInterval then
        local destination = self:GetNextWaypoint()
        
        -- Adjust destination to avoid remembered threats
        destination = self:GetAvoidanceAdjustedDestination(destination)
        
        local path = self:CreatePath(destination)
        if path then
            self:FollowPath(path)
        else
            -- Fallback: direct movement
            self.Humanoid:MoveTo(destination)
        end
        self.LastPathUpdate = currentTime
    end
end

function NPC:UpdateFleeing()
    local currentTime = tick()
    
    -- Check if we should stop fleeing
    if self.ThreatPlayer and self.ThreatPlayer.Character and self.ThreatPlayer.Character:FindFirstChild("HumanoidRootPart") then
        local distance = (self.ThreatPlayer.Character.HumanoidRootPart.Position - self.RootPart.Position).Magnitude
        if distance > self.Config.FleeDistance * 1.5 or currentTime - self.FleeStartTime > 10 then
            self.State = "Returning"
            self.Humanoid.WalkSpeed = self.Config.WalkSpeed
            return
        end
    else
        self.State = "Returning"
        self.Humanoid.WalkSpeed = self.Config.WalkSpeed
        return
    end
    
    -- Continue fleeing
    if currentTime - self.LastPathUpdate > 1 then -- Update flee path more frequently
        local fleeDestination = self:GetFleeDestination()
        local path = self:CreatePath(fleeDestination)
        if path then
            self:FollowPath(path)
        else
            self.Humanoid:MoveTo(fleeDestination)
        end
        self.LastPathUpdate = currentTime
    end
end

function NPC:UpdateReturning()
    local distanceToOriginal = (self.RootPart.Position - self.OriginalPosition).Magnitude
    
    if distanceToOriginal < self.Config.WaypointTolerance then
        -- Arrived back at original position, resume wandering
        wait(self.Config.ReturnDelay)
        self.State = "Wandering"
        self.ThreatPlayer = nil
        self.Humanoid.Health = self.Humanoid.MaxHealth -- Heal the NPC
    else
        -- Path back to original position
        local currentTime = tick()
        if currentTime - self.LastPathUpdate > self.Config.PathUpdateInterval then
            local path = self:CreatePath(self.OriginalPosition)
            if path then
                self:FollowPath(path)
            else
                self.Humanoid:MoveTo(self.OriginalPosition)
            end
            self.LastPathUpdate = currentTime
        end
    end
end

function NPC:StartMainLoop()
    spawn(function()
        while self.Character and self.Character.Parent and self.Humanoid and self.RootPart do
            if self.State == "Wandering" then
                self:UpdateWandering()
            elseif self.State == "Fleeing" then
                self:UpdateFleeing()
            elseif self.State == "Returning" then
                self:UpdateReturning()
            end
            
            wait(0.1) -- Update frequency
        end
    end)
end

-- Initialize the NPC
print("Initializing NPC behavior for " .. character.Name)

-- Set initial properties
humanoid.WalkSpeed = NPC_CONFIG.WalkSpeed
humanoid.MaxHealth = 100
humanoid.Health = 100

-- Create the NPC behavior
local npc = NPC.new(character, NPC_CONFIG)
if npc then
    print("Successfully initialized NPC behavior for " .. character.Name)
else
    warn("Failed to initialize NPC behavior for " .. character.Name)
end
