local RunService = game:GetService("RunService")
local PathfindingService = game:GetService("PathfindingService")
local Players = game:GetService("Players")
local Debris = game:GetService("Debris")

-- Configuration
local NPC_CONFIG = {
	WalkSpeed = 8,
	RunSpeed = 16,
	FleeDistance = 50,
	ReturnDelay = 3,
	PathUpdateInterval = 2,
	WaypointTolerance = 4,
	MaxPathfindingRetries = 3,
	-- Player memory and avoidance
	MemoryDuration = 300, -- How long NPCs remember players (seconds)
	AvoidanceDistance = 25, -- Distance to maintain from remembered threats
	AvoidanceStrength = 1.5, -- How much to bend path away from threats
	-- Waypoint settings
	NPCPointsFolderName = "NPCPoints", -- Name of folder containing waypoint parts
	-- Chain path settings
	MinChainLength = 3, -- Minimum number of waypoints in a chain
	MaxChainLength = 8, -- Maximum number of waypoints in a chain
	MaxWaypointDistance = 30, -- Maximum distance between connected waypoints
	ChainConnectionDistance = 25, -- Distance to consider waypoints as "connected"
	-- Job Integration
	EnableJobs = true, -- Set to false to disable job system
	-- Debug settings
	DebugPrints = true, -- Set to false to disable print statements
	PreventTeleporting = true -- Prevent NPCs from teleporting when hurt
}

-- NPC Class
local NPC = {}
NPC.__index = NPC

function NPC.new(character, config)
	local self = setmetatable({}, NPC)

	self.Character = character
	self.Humanoid = character:FindFirstChild("Humanoid")
	self.RootPart = character:FindFirstChild("HumanoidRootPart")

	if not self.Humanoid or not self.RootPart then
		if config and config.DebugPrints then
			warn("Failed to find Humanoid or HumanoidRootPart in " .. character.Name)
		end
		return nil
	end

	self.Config = config or NPC_CONFIG

	-- State management
	self.State = "Wandering" -- "Wandering", "Fleeing", "Returning", "Working"
	self.OriginalPosition = self.RootPart.Position
	self.OriginalCFrame = self.RootPart.CFrame
	self.CurrentPath = nil
	self.LastPathUpdate = 0
	self.FleeStartTime = 0
	self.ThreatPlayer = nil

	-- Chain pathfinding system
	self.CurrentChain = {}
	self.CurrentChainIndex = 1
	self.WaypointChains = {}
	
	self.PreFleeChain = nil
	self.PreFleeChainIndex = 1

	-- Player memory system
	self.RememberedThreats = {}

	-- Pathfinding setup
	self.PathfindingAgent = {
		AgentRadius = 2,
		AgentHeight = 5,
		AgentCanJump = true,
		WaypointSpacing = 4
	}

	-- Setup components
	self:SetupWaypoints()
	self:SetupInjuryDetection()
	
	-- Initialize job system if enabled
	self.JobSystem = nil
	if self.Config.EnableJobs then
		self:InitializeJobSystem()
	end

	-- Start the main loop
	self:StartMainLoop()

	return self
end

function NPC:InitializeJobSystem()
	-- Wait for job system to be available
	spawn(function()
		local attempts = 0
		while not _G.JobSystem and attempts < 50 do
			wait(0.1)
			attempts = attempts + 1
		end
		
		if _G.JobSystem then
			self.JobSystem = _G.JobSystem.new(self)
			if self.Config.DebugPrints then
				print(self.Character.Name .. " job system initialized")
			end
		elseif self.Config.DebugPrints then
			warn(self.Character.Name .. " could not initialize job system - JobSystem not found")
		end
	end)
end

-- [All the existing functions remain the same - SetupWaypoints, GenerateWaypointChains, etc.]
function NPC:SetupWaypoints()
	local npcPointsFolder = workspace:FindFirstChild(self.Config.NPCPointsFolderName)

	if not npcPointsFolder then
		if self.Config.DebugPrints then
			warn("NPCPoints folder not found in workspace! Creating example waypoints around NPC spawn.")
		end
		self:CreateFallbackWaypoints()
		return
	end

	self.WaypointParts = {}
	for _, child in pairs(npcPointsFolder:GetChildren()) do
		if child:IsA("BasePart") then
			table.insert(self.WaypointParts, child)
		end
	end

	if #self.WaypointParts == 0 then
		if self.Config.DebugPrints then
			warn("No parts found in NPCPoints folder! Creating fallback waypoints.")
		end
		self:CreateFallbackWaypoints()
		return
	end

	if self.Config.DebugPrints then
		print(self.Character.Name .. " found " .. #self.WaypointParts .. " waypoints in " .. self.Config.NPCPointsFolderName)
	end

	self:GenerateWaypointChains()
	self:ChooseNewChain()
end

function NPC:GenerateWaypointChains()
	self.WaypointChains = {}

	for _, startPoint in ipairs(self.WaypointParts) do
		local chains = self:FindChainsFromPoint(startPoint)
		for _, chain in ipairs(chains) do
			table.insert(self.WaypointChains, chain)
		end
	end

	if self.Config.DebugPrints then
		print(self.Character.Name .. " generated " .. #self.WaypointChains .. " waypoint chains")
	end
end

function NPC:FindChainsFromPoint(startPoint)
	local chains = {}
	local visited = {}

	local function buildChain(currentPoint, currentChain, depth)
		if depth > self.Config.MaxChainLength then
			return
		end

		table.insert(currentChain, currentPoint)
		visited[currentPoint] = true

		if #currentChain >= self.Config.MinChainLength then
			local chainCopy = {}
			for i, point in ipairs(currentChain) do
				chainCopy[i] = point
			end
			table.insert(chains, chainCopy)
		end

		local connectedPoints = self:FindConnectedWaypoints(currentPoint, visited)

		for _, nextPoint in ipairs(connectedPoints) do
			buildChain(nextPoint, {unpack(currentChain)}, depth + 1)
		end

		visited[currentPoint] = nil
	end

	buildChain(startPoint, {}, 1)
	return chains
end

function NPC:FindConnectedWaypoints(fromPoint, excludeVisited)
	local connected = {}
	excludeVisited = excludeVisited or {}

	for _, otherPoint in ipairs(self.WaypointParts) do
		if otherPoint ~= fromPoint and not excludeVisited[otherPoint] then
			local distance = (fromPoint.Position - otherPoint.Position).Magnitude
			if distance <= self.Config.ChainConnectionDistance then
				table.insert(connected, otherPoint)
			end
		end
	end

	table.sort(connected, function(a, b)
		local distA = (fromPoint.Position - a.Position).Magnitude
		local distB = (fromPoint.Position - b.Position).Magnitude
		return distA < distB
	end)

	return connected
end

function NPC:ChooseNewChain()
	if #self.WaypointChains == 0 then
		if self.Config.DebugPrints then
			warn(self.Character.Name .. " has no waypoint chains! Using fallback.")
		end
		self:CreateFallbackWaypoints()
		return
	end

	local randomChainIndex = math.random(1, #self.WaypointChains)
	self.CurrentChain = self.WaypointChains[randomChainIndex]
	self.CurrentChainIndex = 1

	if self.Config.DebugPrints then
		print(self.Character.Name .. " chose new chain with " .. #self.CurrentChain .. " waypoints")
	end
end

function NPC:GetCurrentWaypointInChain()
	if not self.CurrentChain or #self.CurrentChain == 0 then
		return self.OriginalPosition
	end

	local waypoint = self.CurrentChain[self.CurrentChainIndex]
	if waypoint then
		return waypoint.Position
	else
		return self.OriginalPosition
	end
end

function NPC:AdvanceInChain()
	if not self.CurrentChain or #self.CurrentChain == 0 then
		return false
	end

	self.CurrentChainIndex = self.CurrentChainIndex + 1

	if self.CurrentChainIndex > #self.CurrentChain then
		if self.Config.DebugPrints then
			print(self.Character.Name .. " completed chain, choosing new one")
		end
		self:ChooseNewChain()
		return true
	end

	if self.Config.DebugPrints then
		print(self.Character.Name .. " advancing to waypoint " .. self.CurrentChainIndex .. " of " .. #self.CurrentChain)
	end

	return true
end

function NPC:CreateFallbackWaypoints()
	local center = self.OriginalPosition
	self.FallbackWaypoints = {
		center + Vector3.new(20, 0, 0),
		center + Vector3.new(0, 0, 20),
		center + Vector3.new(-20, 0, 0),
		center + Vector3.new(0, 0, -20),
		center + Vector3.new(15, 0, 15),
		center + Vector3.new(-15, 0, 15),
		center + Vector3.new(-15, 0, -15),
		center + Vector3.new(15, 0, -15)
	}

	self.CurrentChain = {}
	for i, pos in ipairs(self.FallbackWaypoints) do
		local fakePart = {Position = pos, Name = "Fallback" .. i}
		table.insert(self.CurrentChain, fakePart)
	end
	self.CurrentChainIndex = 1
end

-- [Include all other existing functions like SetupInjuryDetection, OnInjured, etc. - they remain unchanged]
function NPC:SetupInjuryDetection()
	self.Humanoid.HealthChanged:Connect(function(health)
		if health < self.Humanoid.MaxHealth then
			self:OnInjured()
		end
	end)

	self.Character.ChildAdded:Connect(function(child)
		if child:IsA("Tool") then
			self:OnInjured()
		end
	end)

	if self.Config.PreventTeleporting then
		self.Humanoid.PlatformStand = false

		spawn(function()
			while self.Character and self.Character.Parent do
				local currentPos = self.RootPart.Position
				local expectedMaxDistance = 50

				if (currentPos - self.OriginalPosition).Magnitude > expectedMaxDistance * 3 then
					if self.RootPart.Velocity.Y < -50 then
						self.RootPart.CFrame = CFrame.new(self.OriginalPosition + Vector3.new(0, 5, 0))
						self.RootPart.Velocity = Vector3.new(0, 0, 0)

						if self.Config.DebugPrints then
							print("Prevented " .. self.Character.Name .. " from teleporting/falling")
						end
					end
				end

				wait(0.1)
			end
		end)
	end
end

function NPC:OnInjured()
	if self.State == "Fleeing" then return end

	-- Stop any job if working
	if self.State == "Working" and self.JobSystem then
		self.JobSystem:EndJob()
	end

	self.PreFleeChain = self.CurrentChain
	self.PreFleeChainIndex = self.CurrentChainIndex

	local closestPlayer = self:FindClosestPlayer()
	if closestPlayer then
		self:RememberThreat(closestPlayer)

		self.ThreatPlayer = closestPlayer
		self.State = "Fleeing"
		self.FleeStartTime = tick()
		self.Humanoid.WalkSpeed = self.Config.RunSpeed
		
		if self.Config.DebugPrints then
			print(self.Character.Name .. " is fleeing and will return to waypoint " .. self.PreFleeChainIndex .. " of " .. #self.PreFleeChain)
		end
	end
end

-- [Continue with remaining existing functions...]
function NPC:FindClosestPlayer()
	local closestPlayer = nil
	local closestDistance = math.huge

	for _, player in pairs(Players:GetPlayers()) do
		if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
			local distance = (player.Character.HumanoidRootPart.Position - self.RootPart.Position).Magnitude
			if distance < closestDistance then
				closestDistance = distance
				closestPlayer = player
			end
		end
	end

	return closestPlayer
end

function NPC:RememberThreat(player)
	local playerName = player.Name
	if not self.RememberedThreats[playerName] then
		self.RememberedThreats[playerName] = {
			lastSeen = tick(),
			dangerLevel = 1,
			player = player
		}
	else
		self.RememberedThreats[playerName].dangerLevel = self.RememberedThreats[playerName].dangerLevel + 1
		self.RememberedThreats[playerName].lastSeen = tick()
		self.RememberedThreats[playerName].player = player
	end

	if self.Config.DebugPrints then
		print(self.Character.Name .. " now remembers " .. playerName .. " as a threat (Danger Level: " .. 
			self.RememberedThreats[playerName].dangerLevel .. ")")
	end
end

function NPC:ForgetOldThreats()
	local currentTime = tick()
	for playerName, threatData in pairs(self.RememberedThreats) do
		if currentTime - threatData.lastSeen > self.Config.MemoryDuration then
			if self.Config.DebugPrints then
				print(self.Character.Name .. " has forgotten about " .. playerName)
			end
			self.RememberedThreats[playerName] = nil
		end
	end
end

function NPC:GetNearbyThreats()
	local nearbyThreats = {}

	for playerName, threatData in pairs(self.RememberedThreats) do
		if threatData.player and threatData.player.Character and 
			threatData.player.Character:FindFirstChild("HumanoidRootPart") then

			local distance = (threatData.player.Character.HumanoidRootPart.Position - self.RootPart.Position).Magnitude
			if distance <= self.Config.AvoidanceDistance then
				table.insert(nearbyThreats, {
					player = threatData.player,
					distance = distance,
					dangerLevel = threatData.dangerLevel,
					position = threatData.player.Character.HumanoidRootPart.Position
				})
			end
		end
	end

	return nearbyThreats
end

function NPC:GetAvoidanceAdjustedDestination(originalDestination)
	local threats = self:GetNearbyThreats()
	if #threats == 0 then
		return originalDestination
	end

	local avoidanceVector = Vector3.new(0, 0, 0)
	local myPos = self.RootPart.Position

	for _, threat in ipairs(threats) do
		local threatPos = threat.position
		local directionAway = (myPos - threatPos).Unit
		local influence = (self.Config.AvoidanceDistance - threat.distance) / self.Config.AvoidanceDistance
		influence = influence * threat.dangerLevel * self.Config.AvoidanceStrength

		avoidanceVector = avoidanceVector + (directionAway * influence * 20)
	end

	local adjustedDestination = originalDestination + avoidanceVector

	local maxDeviation = 30
	local deviation = (adjustedDestination - originalDestination).Magnitude
	if deviation > maxDeviation then
		local deviationDirection = (adjustedDestination - originalDestination).Unit
		adjustedDestination = originalDestination + (deviationDirection * maxDeviation)
	end

	return adjustedDestination
end

function NPC:GetFleeDestination()
	if not self.ThreatPlayer or not self.ThreatPlayer.Character then
		return self.OriginalPosition
	end

	local threatPos = self.ThreatPlayer.Character.HumanoidRootPart.Position
	local myPos = self.RootPart.Position
	local fleeDirection = (myPos - threatPos).Unit

	local dangerMultiplier = 1
	if self.RememberedThreats[self.ThreatPlayer.Name] then
		dangerMultiplier = self.RememberedThreats[self.ThreatPlayer.Name].dangerLevel
	end

	local fleeDistance = self.Config.FleeDistance * dangerMultiplier
	return myPos + fleeDirection * fleeDistance
end

function NPC:CreatePath(destination)
	local path = PathfindingService:CreatePath(self.PathfindingAgent)
	local success, errorMessage = pcall(function()
		path:ComputeAsync(self.RootPart.Position, destination)
	end)

	if success and path.Status == Enum.PathStatus.Success then
		return path
	else
		if self.Config.DebugPrints then
			warn("Path creation failed for " .. self.Character.Name .. ": " .. tostring(errorMessage))
		end
		return nil
	end
end

function NPC:FollowPath(path)
	if not path then return end

	local waypoints = path:GetWaypoints()
	if #waypoints < 2 then return end

	self.Humanoid:MoveTo(waypoints[2].Position)

	local connection
	connection = self.Humanoid.MoveToFinished:Connect(function(reached)
		if reached and #waypoints > 2 then
			table.remove(waypoints, 1)
			if #waypoints > 1 then
				self.Humanoid:MoveTo(waypoints[2].Position)
			else
				connection:Disconnect()
				self:CheckWaypointReached()
			end
		else
			connection:Disconnect()
			self:CheckWaypointReached()
		end
	end)
end

function NPC:CheckWaypointReached()
	local currentTarget = self:GetCurrentWaypointInChain()
	local distanceToTarget = (self.RootPart.Position - currentTarget).Magnitude

	if distanceToTarget <= self.Config.WaypointTolerance then
		self:AdvanceInChain()
	end
end

function NPC:GetNextWaypoint()
	return self:GetCurrentWaypointInChain()
end

function NPC:FindClosestWaypointInChain(chain)
	if not chain or #chain == 0 then
		return 1
	end

	local closestIndex = 1
	local closestDistance = math.huge
	local myPos = self.RootPart.Position

	for i, waypoint in ipairs(chain) do
		local distance = (myPos - waypoint.Position).Magnitude
		if distance < closestDistance then
			closestDistance = distance
			closestIndex = i
		end
	end

	return closestIndex
end

-- MODIFIED: UpdateWandering now includes job system integration
function NPC:UpdateWandering()
	self:ForgetOldThreats()

	-- Update job system if available
	if self.JobSystem then
		self.JobSystem:Update()
	end

	-- Only do normal wandering movement if not working
	if self.State == "Wandering" then
		local currentTime = tick()
		if currentTime - self.LastPathUpdate > self.Config.PathUpdateInterval then
			local destination = self:GetNextWaypoint()
			destination = self:GetAvoidanceAdjustedDestination(destination)

			local path = self:CreatePath(destination)
			if path then
				self:FollowPath(path)
			else
				self.Humanoid:MoveTo(destination)
			end
			self.LastPathUpdate = currentTime
		end
	end
end

function NPC:UpdateFleeing()
	local currentTime = tick()

	if self.ThreatPlayer and self.ThreatPlayer.Character and self.ThreatPlayer.Character:FindFirstChild("HumanoidRootPart") then
		local distance = (self.ThreatPlayer.Character.HumanoidRootPart.Position - self.RootPart.Position).Magnitude
		if distance > self.Config.FleeDistance * 1.5 or currentTime - self.FleeStartTime > 10 then
			self.State = "Returning"
			self.Humanoid.WalkSpeed = self.Config.WalkSpeed
			return
		end
	else
		self.State = "Returning"
		self.Humanoid.WalkSpeed = self.Config.WalkSpeed
		return
	end

	if currentTime - self.LastPathUpdate > 1 then
		local fleeDestination = self:GetFleeDestination()
		local path = self:CreatePath(fleeDestination)
		if path then
			self:FollowPath(path)
		else
			self.Humanoid:MoveTo(fleeDestination)
		end
		self.LastPathUpdate = currentTime
	end
end

function NPC:UpdateReturning()
	local returnDestination
	if self.PreFleeChain and #self.PreFleeChain > 0 then
		local closestIndex = self:FindClosestWaypointInChain(self.PreFleeChain)
		returnDestination = self.PreFleeChain[closestIndex].Position
		
		if self.Config.DebugPrints then
			print(self.Character.Name .. " returning to waypoint " .. closestIndex .. " in saved chain")
		end
	else
		returnDestination = self.OriginalPosition
	end

	local distanceToReturn = (self.RootPart.Position - returnDestination).Magnitude

	if distanceToReturn < self.Config.WaypointTolerance then
		wait(self.Config.ReturnDelay)
		
		if self.PreFleeChain and #self.PreFleeChain > 0 then
			self.CurrentChain = self.PreFleeChain
			self.CurrentChainIndex = self:FindClosestWaypointInChain(self.PreFleeChain)
			
			if self.Config.DebugPrints then
				print(self.Character.Name .. " resumed chain at waypoint " .. self.CurrentChainIndex)
			end
		end
		
		self.State = "Wandering"
		self.ThreatPlayer = nil
		self.PreFleeChain = nil
		self.PreFleeChainIndex = 1
		self.Humanoid.Health = self.Humanoid.MaxHealth
	else
		local currentTime = tick()
		if currentTime - self.LastPathUpdate > self.Config.PathUpdateInterval then
			local path = self:CreatePath(returnDestination)
			if path then
				self:FollowPath(path)
			else
				self.Humanoid:MoveTo(returnDestination)
			end
			self.LastPathUpdate = currentTime
		end
	end
end

-- MODIFIED: Main loop now handles "Working" state
function NPC:StartMainLoop()
	spawn(function()
		while self.Character and self.Character.Parent and self.Humanoid and self.RootPart do
			if self.State == "Wandering" then
				self:UpdateWandering()
			elseif self.State == "Fleeing" then
				self:UpdateFleeing()
			elseif self.State == "Returning" then
				self:UpdateReturning()
			elseif self.State == "Working" then
				-- Job system handles working state, but we still need to update job system
				if self.JobSystem then
					self.JobSystem:Update()
				end
				-- Don't do movement while working - job system controls this
			end

			wait(0.1)
		end
	end)
end

-- Initialize the NPC
local function InitializeNPC()
	wait(1)

	local character = nil
	local parent = script.Parent
	while parent do
		if parent:IsA("Model") and parent:FindFirstChild("Humanoid") and parent:FindFirstChild("HumanoidRootPart") then
			character = parent
			break
		end
		parent = parent.Parent
	end

	if not character then
		if NPC_CONFIG.DebugPrints then
			warn("Could not find NPC character from script location. Make sure this script is inside an NPC model.")
		end
		return
	end

	local npc = NPC.new(character, NPC_CONFIG)
	if npc then
		if NPC_CONFIG.DebugPrints then
			print("Successfully initialized NPC behavior for " .. character.Name)
		end
		
		-- Store reference globally for job system integration
		_G["NPC_" .. character.Name] = npc
	else
		if NPC_CONFIG.DebugPrints then
			warn("Failed to initialize NPC behavior for " .. character.Name)
		end
	end
end

spawn(InitializeNPC)
