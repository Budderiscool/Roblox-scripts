
local RunService = game:GetService("RunService")
local PathfindingService = game:GetService("PathfindingService")
local Players = game:GetService("Players")
local Debris = game:GetService("Debris")

-- Configuration
local NPC_CONFIG = {
	WalkSpeed = 8,
	RunSpeed = 16,
	FleeDistance = 50,
	ReturnDelay = 3,
	PathUpdateInterval = 2,
	WaypointTolerance = 4,
	MaxPathfindingRetries = 3,
	-- Player memory and avoidance
	MemoryDuration = 300, -- How long NPCs remember players (seconds)
	AvoidanceDistance = 25, -- Distance to maintain from remembered threats
	AvoidanceStrength = 1.5, -- How much to bend path away from threats
	-- Waypoint settings
	NPCPointsFolderName = "NPCPoints", -- Name of folder containing waypoint parts
	-- Chain path settings
	MinChainLength = 3, -- Minimum number of waypoints in a chain
	MaxChainLength = 8, -- Maximum number of waypoints in a chain
	MaxWaypointDistance = 30, -- Maximum distance between connected waypoints
	ChainConnectionDistance = 25, -- Distance to consider waypoints as "connected"
	-- Debug settings
	DebugPrints = true, -- Set to false to disable print statements
	PreventTeleporting = true -- Prevent NPCs from teleporting when hurt
}

-- NPC Class
local NPC = {}
NPC.__index = NPC

function NPC.new(character, config)
	local self = setmetatable({}, NPC)

	self.Character = character
	self.Humanoid = character:FindFirstChild("Humanoid")
	self.RootPart = character:FindFirstChild("HumanoidRootPart")

	if not self.Humanoid or not self.RootPart then
		if config.DebugPrints then
			warn("Failed to find Humanoid or HumanoidRootPart in " .. character.Name)
		end
		return nil
	end

	self.Config = config or NPC_CONFIG

	-- State management
	self.State = "Wandering" -- "Wandering", "Fleeing", "Returning"
	self.OriginalPosition = self.RootPart.Position
	self.OriginalCFrame = self.RootPart.CFrame -- Store original CFrame to prevent teleporting
	self.CurrentPath = nil
	self.LastPathUpdate = 0
	self.FleeStartTime = 0
	self.ThreatPlayer = nil

	-- Chain pathfinding system
	self.CurrentChain = {} -- Current sequence of waypoints to follow
	self.CurrentChainIndex = 1 -- Index in the current chain
	self.WaypointChains = {} -- All possible chains of waypoints

	-- Player memory system
	self.RememberedThreats = {} -- {playerName = {lastSeen = tick(), dangerLevel = number}}

	-- Pathfinding setup
	self.PathfindingAgent = {
		AgentRadius = 2,
		AgentHeight = 5,
		AgentCanJump = true,
		WaypointSpacing = 4
	}

	-- Setup waypoints from NPCPoints folder
	self:SetupWaypoints()

	-- Setup injury detection
	self:SetupInjuryDetection()

	-- Start the main loop
	self:StartMainLoop()

	return self
end

function NPC:SetupWaypoints()
	-- Find NPCPoints folder
	local npcPointsFolder = workspace:FindFirstChild(self.Config.NPCPointsFolderName)

	if not npcPointsFolder then
		if self.Config.DebugPrints then
			warn("NPCPoints folder not found in workspace! Creating example waypoints around NPC spawn.")
		end
		self:CreateFallbackWaypoints()
		return
	end

	-- Get all parts from NPCPoints folder
	self.WaypointParts = {}
	for _, child in pairs(npcPointsFolder:GetChildren()) do
		if child:IsA("BasePart") then
			table.insert(self.WaypointParts, child)
		end
	end

	if #self.WaypointParts == 0 then
		if self.Config.DebugPrints then
			warn("No parts found in NPCPoints folder! Creating fallback waypoints.")
		end
		self:CreateFallbackWaypoints()
		return
	end

	if self.Config.DebugPrints then
		print(self.Character.Name .. " found " .. #self.WaypointParts .. " waypoints in " .. self.Config.NPCPointsFolderName)
	end

	-- Generate waypoint chains instead of random waypoints
	self:GenerateWaypointChains()

	-- Choose initial chain
	self:ChooseNewChain()
end

function NPC:GenerateWaypointChains()
	-- Create chains of connected waypoints
	self.WaypointChains = {}

	-- For each waypoint, try to create chains starting from it
	for _, startPoint in ipairs(self.WaypointParts) do
		local chains = self:FindChainsFromPoint(startPoint)
		for _, chain in ipairs(chains) do
			table.insert(self.WaypointChains, chain)
		end
	end

	if self.Config.DebugPrints then
		print(self.Character.Name .. " generated " .. #self.WaypointChains .. " waypoint chains")
	end
end

function NPC:FindChainsFromPoint(startPoint)
	local chains = {}
	local visited = {}

	-- Find all possible chains starting from this point
	local function buildChain(currentPoint, currentChain, depth)
		-- Prevent infinite recursion
		if depth > self.Config.MaxChainLength then
			return
		end

		-- Add current point to chain
		table.insert(currentChain, currentPoint)
		visited[currentPoint] = true

		-- If we have a decent chain length, save it
		if #currentChain >= self.Config.MinChainLength then
			local chainCopy = {}
			for i, point in ipairs(currentChain) do
				chainCopy[i] = point
			end
			table.insert(chains, chainCopy)
		end

		-- Find connected waypoints
		local connectedPoints = self:FindConnectedWaypoints(currentPoint, visited)

		-- Continue building chains with connected points
		for _, nextPoint in ipairs(connectedPoints) do
			buildChain(nextPoint, {unpack(currentChain)}, depth + 1)
		end

		visited[currentPoint] = nil
	end

	buildChain(startPoint, {}, 1)
	return chains
end

function NPC:FindConnectedWaypoints(fromPoint, excludeVisited)
	local connected = {}
	excludeVisited = excludeVisited or {}

	for _, otherPoint in ipairs(self.WaypointParts) do
		if otherPoint ~= fromPoint and not excludeVisited[otherPoint] then
			local distance = (fromPoint.Position - otherPoint.Position).Magnitude
			if distance <= self.Config.ChainConnectionDistance then
				table.insert(connected, otherPoint)
			end
		end
	end

	-- Sort by distance (closest first)
	table.sort(connected, function(a, b)
		local distA = (fromPoint.Position - a.Position).Magnitude
		local distB = (fromPoint.Position - b.Position).Magnitude
		return distA < distB
	end)

	return connected
end

function NPC:ChooseNewChain()
	if #self.WaypointChains == 0 then
		if self.Config.DebugPrints then
			warn(self.Character.Name .. " has no waypoint chains! Using fallback.")
		end
		self:CreateFallbackWaypoints()
		return
	end

	-- Choose a random chain
	local randomChainIndex = math.random(1, #self.WaypointChains)
	self.CurrentChain = self.WaypointChains[randomChainIndex]
	self.CurrentChainIndex = 1

	if self.Config.DebugPrints then
		print(self.Character.Name .. " chose new chain with " .. #self.CurrentChain .. " waypoints")
	end
end

function NPC:GetCurrentWaypointInChain()
	if not self.CurrentChain or #self.CurrentChain == 0 then
		return self.OriginalPosition
	end

	local waypoint = self.CurrentChain[self.CurrentChainIndex]
	if waypoint then
		return waypoint.Position
	else
		return self.OriginalPosition
	end
end

function NPC:AdvanceInChain()
	if not self.CurrentChain or #self.CurrentChain == 0 then
		return false
	end

	self.CurrentChainIndex = self.CurrentChainIndex + 1

	-- If we've reached the end of the chain, choose a new one
	if self.CurrentChainIndex > #self.CurrentChain then
		if self.Config.DebugPrints then
			print(self.Character.Name .. " completed chain, choosing new one")
		end
		self:ChooseNewChain()
		return true
	end

	if self.Config.DebugPrints then
		print(self.Character.Name .. " advancing to waypoint " .. self.CurrentChainIndex .. " of " .. #self.CurrentChain)
	end

	return true
end

function NPC:CreateFallbackWaypoints()
	-- Create waypoints around the NPC's spawn position
	local center = self.OriginalPosition
	self.FallbackWaypoints = {
		center + Vector3.new(20, 0, 0),
		center + Vector3.new(0, 0, 20),
		center + Vector3.new(-20, 0, 0),
		center + Vector3.new(0, 0, -20),
		center + Vector3.new(15, 0, 15),
		center + Vector3.new(-15, 0, 15),
		center + Vector3.new(-15, 0, -15),
		center + Vector3.new(15, 0, -15)
	}

	-- Create a simple chain from fallback waypoints
	self.CurrentChain = {}
	for i, pos in ipairs(self.FallbackWaypoints) do
		-- Create fake parts for consistency
		local fakePart = {Position = pos, Name = "Fallback" .. i}
		table.insert(self.CurrentChain, fakePart)
	end
	self.CurrentChainIndex = 1
end

function NPC:SetupInjuryDetection()
	-- Detect when NPC takes damage
	self.Humanoid.HealthChanged:Connect(function(health)
		if health < self.Humanoid.MaxHealth then
			self:OnInjured()
		end
	end)

	-- Also detect when hit by tools/weapons
	self.Character.ChildAdded:Connect(function(child)
		if child:IsA("Tool") then
			self:OnInjured()
		end
	end)

	-- Prevent teleporting when hurt
	if self.Config.PreventTeleporting then
		self.Humanoid.PlatformStand = false

		-- Monitor for unwanted position changes
		spawn(function()
			while self.Character and self.Character.Parent do
				local currentPos = self.RootPart.Position
				local expectedMaxDistance = 50 -- Maximum reasonable distance the NPC should move in one frame

				if (currentPos - self.OriginalPosition).Magnitude > expectedMaxDistance * 3 then
					-- If NPC has moved too far from original position unexpectedly, check if it's falling
					if self.RootPart.Velocity.Y < -50 then
						-- NPC is falling too fast, likely teleported upward, restore position
						self.RootPart.CFrame = CFrame.new(self.OriginalPosition + Vector3.new(0, 5, 0))
						self.RootPart.Velocity = Vector3.new(0, 0, 0)

						if self.Config.DebugPrints then
							print("Prevented " .. self.Character.Name .. " from teleporting/falling")
						end
					end
				end

				wait(0.1)
			end
		end)
	end
end

function NPC:OnInjured()
	if self.State == "Fleeing" then return end

	-- Find the closest player as the threat
	local closestPlayer = self:FindClosestPlayer()
	if closestPlayer then
		-- Remember this player as a threat
		self:RememberThreat(closestPlayer)

		self.ThreatPlayer = closestPlayer
		self.State = "Fleeing"
		self.FleeStartTime = tick()
		self.Humanoid.WalkSpeed = self.Config.RunSpeed
	end
end

function NPC:FindClosestPlayer()
	local closestPlayer = nil
	local closestDistance = math.huge

	for _, player in pairs(Players:GetPlayers()) do
		if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
			local distance = (player.Character.HumanoidRootPart.Position - self.RootPart.Position).Magnitude
			if distance < closestDistance then
				closestDistance = distance
				closestPlayer = player
			end
		end
	end

	return closestPlayer
end

function NPC:RememberThreat(player)
	local playerName = player.Name
	if not self.RememberedThreats[playerName] then
		self.RememberedThreats[playerName] = {
			lastSeen = tick(),
			dangerLevel = 1,
			player = player
		}
	else
		-- Increase danger level for repeat offenders
		self.RememberedThreats[playerName].dangerLevel = self.RememberedThreats[playerName].dangerLevel + 1
		self.RememberedThreats[playerName].lastSeen = tick()
		self.RememberedThreats[playerName].player = player
	end

	if self.Config.DebugPrints then
		print(self.Character.Name .. " now remembers " .. playerName .. " as a threat (Danger Level: " .. 
			self.RememberedThreats[playerName].dangerLevel .. ")")
	end
end

function NPC:ForgetOldThreats()
	local currentTime = tick()
	for playerName, threatData in pairs(self.RememberedThreats) do
		if currentTime - threatData.lastSeen > self.Config.MemoryDuration then
			if self.Config.DebugPrints then
				print(self.Character.Name .. " has forgotten about " .. playerName)
			end
			self.RememberedThreats[playerName] = nil
		end
	end
end

function NPC:GetNearbyThreats()
	local nearbyThreats = {}

	for playerName, threatData in pairs(self.RememberedThreats) do
		if threatData.player and threatData.player.Character and 
			threatData.player.Character:FindFirstChild("HumanoidRootPart") then

			local distance = (threatData.player.Character.HumanoidRootPart.Position - self.RootPart.Position).Magnitude
			if distance <= self.Config.AvoidanceDistance then
				table.insert(nearbyThreats, {
					player = threatData.player,
					distance = distance,
					dangerLevel = threatData.dangerLevel,
					position = threatData.player.Character.HumanoidRootPart.Position
				})
			end
		end
	end

	return nearbyThreats
end

function NPC:GetAvoidanceAdjustedDestination(originalDestination)
	local threats = self:GetNearbyThreats()
	if #threats == 0 then
		return originalDestination
	end

	local avoidanceVector = Vector3.new(0, 0, 0)
	local myPos = self.RootPart.Position

	-- Calculate avoidance vector based on all nearby threats
	for _, threat in ipairs(threats) do
		local threatPos = threat.position
		local directionAway = (myPos - threatPos).Unit
		local influence = (self.Config.AvoidanceDistance - threat.distance) / self.Config.AvoidanceDistance
		influence = influence * threat.dangerLevel * self.Config.AvoidanceStrength

		avoidanceVector = avoidanceVector + (directionAway * influence * 20)
	end

	-- Apply avoidance to destination
	local adjustedDestination = originalDestination + avoidanceVector

	-- Make sure the adjusted destination is still reasonable (not too far off course)
	local maxDeviation = 30
	local deviation = (adjustedDestination - originalDestination).Magnitude
	if deviation > maxDeviation then
		local deviationDirection = (adjustedDestination - originalDestination).Unit
		adjustedDestination = originalDestination + (deviationDirection * maxDeviation)
	end

	return adjustedDestination
end

function NPC:GetFleeDestination()
	if not self.ThreatPlayer or not self.ThreatPlayer.Character then
		return self.OriginalPosition
	end

	local threatPos = self.ThreatPlayer.Character.HumanoidRootPart.Position
	local myPos = self.RootPart.Position
	local fleeDirection = (myPos - threatPos).Unit

	-- Flee further away from players with higher danger levels
	local dangerMultiplier = 1
	if self.RememberedThreats[self.ThreatPlayer.Name] then
		dangerMultiplier = self.RememberedThreats[self.ThreatPlayer.Name].dangerLevel
	end

	local fleeDistance = self.Config.FleeDistance * dangerMultiplier
	return myPos + fleeDirection * fleeDistance
end

function NPC:CreatePath(destination)
	local path = PathfindingService:CreatePath(self.PathfindingAgent)
	local success, errorMessage = pcall(function()
		path:ComputeAsync(self.RootPart.Position, destination)
	end)

	if success and path.Status == Enum.PathStatus.Success then
		return path
	else
		if self.Config.DebugPrints then
			warn("Path creation failed for " .. self.Character.Name .. ": " .. tostring(errorMessage))
		end
		return nil
	end
end

function NPC:FollowPath(path)
	if not path then return end

	local waypoints = path:GetWaypoints()
	if #waypoints < 2 then return end

	self.Humanoid:MoveTo(waypoints[2].Position) -- Skip first waypoint (current position)

	-- Handle waypoint reached
	local connection
	connection = self.Humanoid.MoveToFinished:Connect(function(reached)
		if reached and #waypoints > 2 then
			table.remove(waypoints, 1)
			if #waypoints > 1 then
				self.Humanoid:MoveTo(waypoints[2].Position)
			else
				connection:Disconnect()
				-- Check if we've reached our target waypoint in the chain
				self:CheckWaypointReached()
			end
		else
			connection:Disconnect()
			-- Check if we've reached our target waypoint in the chain
			self:CheckWaypointReached()
		end
	end)
end

function NPC:CheckWaypointReached()
	local currentTarget = self:GetCurrentWaypointInChain()
	local distanceToTarget = (self.RootPart.Position - currentTarget).Magnitude

	if distanceToTarget <= self.Config.WaypointTolerance then
		-- We've reached the current waypoint in the chain, advance to next
		self:AdvanceInChain()
	end
end

function NPC:GetNextWaypoint()
	-- Get the current waypoint from the chain
	return self:GetCurrentWaypointInChain()
end

function NPC:UpdateWandering()
	-- Clean up old threat memories
	self:ForgetOldThreats()

	local currentTime = tick()
	if currentTime - self.LastPathUpdate > self.Config.PathUpdateInterval then
		local destination = self:GetNextWaypoint()

		-- Adjust destination to avoid remembered threats
		destination = self:GetAvoidanceAdjustedDestination(destination)

		local path = self:CreatePath(destination)
		if path then
			self:FollowPath(path)
		else
			-- Fallback: direct movement
			self.Humanoid:MoveTo(destination)
		end
		self.LastPathUpdate = currentTime
	end
end

function NPC:UpdateFleeing()
	local currentTime = tick()

	-- Check if we should stop fleeing
	if self.ThreatPlayer and self.ThreatPlayer.Character and self.ThreatPlayer.Character:FindFirstChild("HumanoidRootPart") then
		local distance = (self.ThreatPlayer.Character.HumanoidRootPart.Position - self.RootPart.Position).Magnitude
		if distance > self.Config.FleeDistance * 1.5 or currentTime - self.FleeStartTime > 10 then
			self.State = "Returning"
			self.Humanoid.WalkSpeed = self.Config.WalkSpeed
			return
		end
	else
		self.State = "Returning"
		self.Humanoid.WalkSpeed = self.Config.WalkSpeed
		return
	end

	-- Continue fleeing
	if currentTime - self.LastPathUpdate > 1 then -- Update flee path more frequently
		local fleeDestination = self:GetFleeDestination()
		local path = self:CreatePath(fleeDestination)
		if path then
			self:FollowPath(path)
		else
			self.Humanoid:MoveTo(fleeDestination)
		end
		self.LastPathUpdate = currentTime
	end
end

function NPC:UpdateReturning()
	local distanceToOriginal = (self.RootPart.Position - self.OriginalPosition).Magnitude

	if distanceToOriginal < self.Config.WaypointTolerance then
		-- Arrived back at original position, resume wandering
		wait(self.Config.ReturnDelay)
		self.State = "Wandering"
		self.ThreatPlayer = nil
		self.Humanoid.Health = self.Humanoid.MaxHealth -- Heal the NPC
	else
		-- Path back to original position
		local currentTime = tick()
		if currentTime - self.LastPathUpdate > self.Config.PathUpdateInterval then
			local path = self:CreatePath(self.OriginalPosition)
			if path then
				self:FollowPath(path)
			else
				self.Humanoid:MoveTo(self.OriginalPosition)
			end
			self.LastPathUpdate = currentTime
		end
	end
end

function NPC:StartMainLoop()
	spawn(function()
		while self.Character and self.Character.Parent and self.Humanoid and self.RootPart do
			if self.State == "Wandering" then
				self:UpdateWandering()
			elseif self.State == "Fleeing" then
				self:UpdateFleeing()
			elseif self.State == "Returning" then
				self:UpdateReturning()
			end

			wait(0.1) -- Update frequency
		end
	end)
end

-- Initialize the NPC
local function InitializeNPC()
	-- Wait a moment for the character to fully load
	wait(1)

	-- Find the character this script belongs to
	local character = nil

	-- Check if script is inside a model (the NPC)
	local parent = script.Parent
	while parent do
		if parent:IsA("Model") and parent:FindFirstChild("Humanoid") and parent:FindFirstChild("HumanoidRootPart") then
			character = parent
			break
		end
		parent = parent.Parent
	end

	-- If we couldn't find the character from the script's parent hierarchy,
	-- try to find it in workspace
	if not character then
		if NPC_CONFIG.DebugPrints then
			warn("Could not find NPC character from script location. Make sure this script is inside an NPC model.")
		end
		return
	end

	-- Create the NPC behavior
	local npc = NPC.new(character, NPC_CONFIG)
	if npc then
		if NPC_CONFIG.DebugPrints then
			print("Successfully initialized NPC behavior for " .. character.Name)
		end
	else
		if NPC_CONFIG.DebugPrints then
			warn("Failed to initialize NPC behavior for " .. character.Name)
		end
	end
end

-- Start the NPC initialization
spawn(InitializeNPC)
