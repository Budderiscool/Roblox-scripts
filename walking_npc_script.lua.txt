local RunService = game:GetService("RunService")
local PathfindingService = game:GetService("PathfindingService")
local Players = game:GetService("Players")
local Debris = game:GetService("Debris")

-- Configuration
local NPC_CONFIG = {
	WalkSpeed = 8,
	RunSpeed = 16,
	FleeDistance = 50,
	ReturnDelay = 4,
	PathUpdateInterval = 2,
	WaypointTolerance = 4,
	MaxPathfindingRetries = 3,
	-- Player memory and avoidance
	MemoryDuration = 300, -- How long NPCs remember players (seconds)
	AvoidanceDistance = 25, -- Distance to maintain from remembered threats
	AvoidanceStrength = 1.5, -- How much to bend path away from threats
	-- Waypoint settings
	NPCPointsFolderName = "NPCPoints", -- Name of folder containing waypoint parts
	JobSitesFolderName = "JobSites", -- Name of folder containing job site parts
	-- Chain path settings
	MinChainLength = 1, -- Minimum number of waypoints in a chain
	MaxChainLength = 12, -- Maximum number of waypoints in a chain
	MaxWaypointDistance = 30, -- Maximum distance between connected waypoints
	ChainConnectionDistance = 10, -- Distance to consider waypoints as "connected"
	-- Time system settings
	TimeScale = 1, -- Time multiplier (1 = real time, 60 = 1 minute = 1 hour)
	DayLengthMinutes = 24, -- Length of a full day in real minutes (when TimeScale = 60)
	-- Debug settings
	DebugPrints = false, -- Set to false to disable print statements
	PreventTeleporting = true -- Prevent NPCs from teleporting when hurt
}

-- Time System
local TimeSystem = {}
TimeSystem.__index = TimeSystem

function TimeSystem.new(config)
	local self = setmetatable({}, TimeSystem)

	self.Config = config or NPC_CONFIG
	self.StartTime = tick()
	self.CurrentDay = 1

	-- Time format: hours (0-23), minutes (0-59)
	self.CurrentTime = {hour = 6, minute = 0} -- Start at 6:00 AM

	-- Callbacks for time events
	self.TimeCallbacks = {} -- {hour = {minute = {callback1, callback2, ...}}}

	-- Start the time update loop
	self:StartTimeLoop()

	return self
end

function TimeSystem:GetCurrentTime()
	return self.CurrentTime.hour, self.CurrentTime.minute
end

function TimeSystem:GetTimeString()
	local hour = self.CurrentTime.hour
	local minute = self.CurrentTime.minute
	local ampm = hour >= 12 and "PM" or "AM"
	local displayHour = hour == 0 and 12 or (hour > 12 and hour - 12 or hour)
	return string.format("%d:%02d %s", displayHour, minute, ampm)
end

function TimeSystem:RegisterTimeCallback(hour, minute, callback)
	if not self.TimeCallbacks[hour] then
		self.TimeCallbacks[hour] = {}
	end
	if not self.TimeCallbacks[hour][minute] then
		self.TimeCallbacks[hour][minute] = {}
	end
	table.insert(self.TimeCallbacks[hour][minute], callback)
end

function TimeSystem:StartTimeLoop()
	spawn(function()
		while true do
			-- Calculate elapsed time
			local realElapsed = tick() - self.StartTime
			local gameElapsed = realElapsed * self.Config.TimeScale

			-- Convert to game time
			local totalMinutes = gameElapsed / 60
			local dayMinutes = totalMinutes % (self.Config.DayLengthMinutes * 60)

			local newHour = math.floor(dayMinutes / 60) % 24
			local newMinute = math.floor(dayMinutes % 60)

			-- Check if time has changed
			if newHour ~= self.CurrentTime.hour or newMinute ~= self.CurrentTime.minute then
				local oldHour = self.CurrentTime.hour
				local oldMinute = self.CurrentTime.minute

				self.CurrentTime.hour = newHour
				self.CurrentTime.minute = newMinute

				-- Check for day change
				if newHour < oldHour or (newHour == oldHour and newMinute < oldMinute) then
					self.CurrentDay = self.CurrentDay + 1
				end

				-- Trigger callbacks
				self:TriggerTimeCallbacks(newHour, newMinute)

				if self.Config.DebugPrints then
					print("Time: " .. self:GetTimeString() .. " (Day " .. self.CurrentDay .. ")")
				end
			end

			wait(0.1)
		end
	end)
end

function TimeSystem:TriggerTimeCallbacks(hour, minute)
	if self.TimeCallbacks[hour] and self.TimeCallbacks[hour][minute] then
		for _, callback in ipairs(self.TimeCallbacks[hour][minute]) do
			spawn(function()
				callback(hour, minute, self.CurrentDay)
			end)
		end
	end
end

-- Job Schedule Class
local JobSchedule = {}
JobSchedule.__index = JobSchedule

function JobSchedule.new(jobSiteName, startHour, startMinute, durationMinutes)
	local self = setmetatable({}, JobSchedule)

	self.JobSiteName = jobSiteName
	self.StartHour = startHour
	self.StartMinute = startMinute
	self.DurationMinutes = durationMinutes

	-- Calculate end time
	local totalStartMinutes = startHour * 60 + startMinute
	local totalEndMinutes = totalStartMinutes + durationMinutes

	self.EndHour = math.floor(totalEndMinutes / 60) % 24
	self.EndMinute = totalEndMinutes % 60

	return self
end

function JobSchedule:IsActiveAt(hour, minute)
	local currentTotalMinutes = hour * 60 + minute
	local startTotalMinutes = self.StartHour * 60 + self.StartMinute
	local endTotalMinutes = self.EndHour * 60 + self.EndMinute

	-- Handle overnight jobs
	if endTotalMinutes < startTotalMinutes then
		return currentTotalMinutes >= startTotalMinutes or currentTotalMinutes <= endTotalMinutes
	else
		return currentTotalMinutes >= startTotalMinutes and currentTotalMinutes <= endTotalMinutes
	end
end

-- Enhanced NPC Class with Job System
local NPC = {}
NPC.__index = NPC

function NPC.new(character, config, timeSystem)
	local self = setmetatable({}, NPC)

	self.Character = character
	self.Humanoid = character:FindFirstChild("Humanoid")
	self.RootPart = character:FindFirstChild("HumanoidRootPart")

	if not self.Humanoid or not self.RootPart then
		if config.DebugPrints then
			warn("Failed to find Humanoid or HumanoidRootPart in " .. character.Name)
		end
		return nil
	end

	self.Config = config or NPC_CONFIG
	self.TimeSystem = timeSystem

	-- State management - Added "Working" state
	self.State = "Wandering" -- "Wandering", "Fleeing", "Returning", "GoingToWork", "Working", "LeavingWork"
	self.OriginalPosition = self.RootPart.Position
	self.OriginalCFrame = self.RootPart.CFrame
	self.CurrentPath = nil
	self.LastPathUpdate = 0
	self.FleeStartTime = 0
	self.ThreatPlayer = nil

	-- Job system
	self.JobSchedules = {} -- Array of JobSchedule objects
	self.CurrentJob = nil
	self.JobSites = {} -- {jobSiteName = part}
	self.WorkStartTime = 0

	-- Chain pathfinding system
	self.CurrentChain = {}
	self.CurrentChainIndex = 1
	self.WaypointChains = {}

	-- Store chain before work/fleeing
	self.PreWorkChain = nil
	self.PreWorkChainIndex = 1
	self.PreFleeChain = nil
	self.PreFleeChainIndex = 1

	-- Player memory system
	self.RememberedThreats = {}

	-- Pathfinding setup
	self.PathfindingAgent = {
		AgentRadius = 2,
		AgentHeight = 5,
		AgentCanJump = true,
		WaypointSpacing = 4
	}

	-- Setup systems
	self:SetupWaypoints()
	self:SetupJobSites()
	self:SetupInjuryDetection()
	self:SetupJobScheduling()

	-- Start the main loop
	self:StartMainLoop()

	return self
end

function NPC:SetupJobSites()
	-- Find JobSites folder
	local jobSitesFolder = workspace:FindFirstChild(self.Config.JobSitesFolderName)

	if not jobSitesFolder then
		if self.Config.DebugPrints then
			warn("JobSites folder not found in workspace! NPCs won't have jobs.")
		end
		return
	end

	-- Get all job site parts
	for _, child in pairs(jobSitesFolder:GetChildren()) do
		if child:IsA("BasePart") then
			self.JobSites[child.Name] = child
		end
	end

	if self.Config.DebugPrints then
		print(self.Character.Name .. " found " .. #self.JobSites .. " job sites")
	end
end

function NPC:AddJobSchedule(jobSiteName, startHour, startMinute, durationMinutes)
	local schedule = JobSchedule.new(jobSiteName, startHour, startMinute, durationMinutes)
	table.insert(self.JobSchedules, schedule)

	if self.Config.DebugPrints then
		print(self.Character.Name .. " scheduled to work at " .. jobSiteName .. 
			" from " .. startHour .. ":" .. string.format("%02d", startMinute) .. 
			" for " .. durationMinutes .. " minutes")
	end
end

function NPC:SetupJobScheduling()
	if not self.TimeSystem then return end

	-- Check for work every minute
	spawn(function()
		while self.Character and self.Character.Parent do
			local hour, minute = self.TimeSystem:GetCurrentTime()
			self:CheckWorkSchedule(hour, minute)
			wait(60 / self.Config.TimeScale) -- Check every game minute
		end
	end)
end

function NPC:CheckWorkSchedule(hour, minute)
	-- Don't interrupt fleeing
	if self.State == "Fleeing" then return end

	-- Check if we should be working
	for _, schedule in ipairs(self.JobSchedules) do
		if schedule:IsActiveAt(hour, minute) then
			if self.State ~= "Working" and self.State ~= "GoingToWork" then
				self:StartWork(schedule)
			end
			return
		end
	end

	-- Check if we should stop working
	if self.State == "Working" or self.State == "GoingToWork" then
		local shouldWork = false
		for _, schedule in ipairs(self.JobSchedules) do
			if schedule:IsActiveAt(hour, minute) then
				shouldWork = true
				break
			end
		end

		if not shouldWork then
			self:EndWork()
		end
	end
end

function NPC:StartWork(schedule)
	if not self.JobSites[schedule.JobSiteName] then
		if self.Config.DebugPrints then
			warn(self.Character.Name .. " cannot find job site: " .. schedule.JobSiteName)
		end
		return
	end

	-- Save current wandering state
	self.PreWorkChain = self.CurrentChain
	self.PreWorkChainIndex = self.CurrentChainIndex

	self.CurrentJob = schedule
	self.State = "GoingToWork"
	self.WorkStartTime = tick()

	if self.Config.DebugPrints then
		print(self.Character.Name .. " is going to work at " .. schedule.JobSiteName)
	end
end

function NPC:EndWork()
	if self.Config.DebugPrints then
		print(self.Character.Name .. " is leaving work")
	end

	self.State = "LeavingWork"
	self.CurrentJob = nil
end

function NPC:GetJobSitePosition()
	if not self.CurrentJob or not self.JobSites[self.CurrentJob.JobSiteName] then
		return self.OriginalPosition
	end

	return self.JobSites[self.CurrentJob.JobSiteName].Position
end

-- Update the existing methods to handle new states
function NPC:UpdateGoingToWork()
	local jobSitePos = self:GetJobSitePosition()
	local distance = (self.RootPart.Position - jobSitePos).Magnitude

	if distance <= self.Config.WaypointTolerance then
		-- Arrived at work
		self.State = "Working"
		self.Humanoid:MoveTo(self.RootPart.Position) -- Stop moving

		if self.Config.DebugPrints then
			print(self.Character.Name .. " arrived at work")
		end
	else
		-- Path to job site
		local currentTime = tick()
		if currentTime - self.LastPathUpdate > self.Config.PathUpdateInterval then
			local path = self:CreatePath(jobSitePos)
			if path then
				self:FollowPath(path)
			else
				self.Humanoid:MoveTo(jobSitePos)
			end
			self.LastPathUpdate = currentTime
		end
	end
end

function NPC:UpdateWorking()
	-- NPC stands at job site and occasionally moves slightly
	if math.random(1, 100) <= 2 then -- 2% chance per update to move slightly
		local jobSitePos = self:GetJobSitePosition()
		local randomOffset = Vector3.new(
			math.random(-3, 3),
			0,
			math.random(-3, 3)
		)
		self.Humanoid:MoveTo(jobSitePos + randomOffset)
	end
end

function NPC:UpdateLeavingWork()
	-- Return to where we were wandering before work
	local returnDestination
	if self.PreWorkChain and #self.PreWorkChain > 0 then
		local closestIndex = self:FindClosestWaypointInChain(self.PreWorkChain)
		returnDestination = self.PreWorkChain[closestIndex].Position
	else
		returnDestination = self.OriginalPosition
	end

	local distance = (self.RootPart.Position - returnDestination).Magnitude

	if distance <= self.Config.WaypointTolerance then
		-- Back to wandering area
		if self.PreWorkChain and #self.PreWorkChain > 0 then
			self.CurrentChain = self.PreWorkChain
			self.CurrentChainIndex = self:FindClosestWaypointInChain(self.PreWorkChain)
		end

		self.State = "Wandering"
		self.PreWorkChain = nil
		self.PreWorkChainIndex = 1

		if self.Config.DebugPrints then
			print(self.Character.Name .. " returned to wandering")
		end
	else
		-- Path back to wandering area
		local currentTime = tick()
		if currentTime - self.LastPathUpdate > self.Config.PathUpdateInterval then
			local path = self:CreatePath(returnDestination)
			if path then
				self:FollowPath(path)
			else
				self.Humanoid:MoveTo(returnDestination)
			end
			self.LastPathUpdate = currentTime
		end
	end
end

-- [Include all the original methods here - SetupWaypoints, GenerateWaypointChains, etc.]
-- For brevity, I'm showing the key new methods. The original methods remain the same.

function NPC:SetupWaypoints()
	-- Find NPCPoints folder
	local npcPointsFolder = workspace:FindFirstChild(self.Config.NPCPointsFolderName)

	if not npcPointsFolder then
		if self.Config.DebugPrints then
			warn("NPCPoints folder not found in workspace! Creating example waypoints around NPC spawn.")
		end
		self:CreateFallbackWaypoints()
		return
	end

	-- Get all parts from NPCPoints folder
	self.WaypointParts = {}
	for _, child in pairs(npcPointsFolder:GetChildren()) do
		if child:IsA("BasePart") then
			table.insert(self.WaypointParts, child)
		end
	end

	if #self.WaypointParts == 0 then
		if self.Config.DebugPrints then
			warn("No parts found in NPCPoints folder! Creating fallback waypoints.")
		end
		self:CreateFallbackWaypoints()
		return
	end

	if self.Config.DebugPrints then
		print(self.Character.Name .. " found " .. #self.WaypointParts .. " waypoints in " .. self.Config.NPCPointsFolderName)
	end

	-- Generate waypoint chains instead of random waypoints
	self:GenerateWaypointChains()

	-- Choose initial chain
	self:ChooseNewChain()
end

function NPC:GenerateWaypointChains()
	-- Create chains of connected waypoints
	self.WaypointChains = {}

	-- For each waypoint, try to create chains starting from it
	for _, startPoint in ipairs(self.WaypointParts) do
		local chains = self:FindChainsFromPoint(startPoint)
		for _, chain in ipairs(chains) do
			table.insert(self.WaypointChains, chain)
		end
	end

	if self.Config.DebugPrints then
		print(self.Character.Name .. " generated " .. #self.WaypointChains .. " waypoint chains")
	end
end

function NPC:FindChainsFromPoint(startPoint)
	local chains = {}
	local visited = {}

	-- Find all possible chains starting from this point
	local function buildChain(currentPoint, currentChain, depth)
		-- Prevent infinite recursion
		if depth > self.Config.MaxChainLength then
			return
		end

		-- Add current point to chain
		table.insert(currentChain, currentPoint)
		visited[currentPoint] = true

		-- If we have a decent chain length, save it
		if #currentChain >= self.Config.MinChainLength then
			local chainCopy = {}
			for i, point in ipairs(currentChain) do
				chainCopy[i] = point
			end
			table.insert(chains, chainCopy)
		end

		-- Find connected waypoints
		local connectedPoints = self:FindConnectedWaypoints(currentPoint, visited)

		-- Continue building chains with connected points
		for _, nextPoint in ipairs(connectedPoints) do
			buildChain(nextPoint, {unpack(currentChain)}, depth + 1)
		end

		visited[currentPoint] = nil
	end

	buildChain(startPoint, {}, 1)
	return chains
end

function NPC:FindConnectedWaypoints(fromPoint, excludeVisited)
	local connected = {}
	excludeVisited = excludeVisited or {}

	for _, otherPoint in ipairs(self.WaypointParts) do
		if otherPoint ~= fromPoint and not excludeVisited[otherPoint] then
			local distance = (fromPoint.Position - otherPoint.Position).Magnitude
			if distance <= self.Config.ChainConnectionDistance then
				table.insert(connected, otherPoint)
			end
		end
	end

	-- Sort by distance (closest first)
	table.sort(connected, function(a, b)
		local distA = (fromPoint.Position - a.Position).Magnitude
		local distB = (fromPoint.Position - b.Position).Magnitude
		return distA < distB
	end)

	return connected
end

function NPC:ChooseNewChain()
	if #self.WaypointChains == 0 then
		if self.Config.DebugPrints then
			warn(self.Character.Name .. " has no waypoint chains! Using fallback.")
		end
		self:CreateFallbackWaypoints()
		return
	end

	-- Choose a random chain
	local randomChainIndex = math.random(1, #self.WaypointChains)
	self.CurrentChain = self.WaypointChains[randomChainIndex]
	self.CurrentChainIndex = 1

	if self.Config.DebugPrints then
		print(self.Character.Name .. " chose new chain with " .. #self.CurrentChain .. " waypoints")
	end
end

function NPC:GetCurrentWaypointInChain()
	if not self.CurrentChain or #self.CurrentChain == 0 then
		return self.OriginalPosition
	end

	local waypoint = self.CurrentChain[self.CurrentChainIndex]
	if waypoint then
		return waypoint.Position
	else
		return self.OriginalPosition
	end
end

function NPC:AdvanceInChain()
	if not self.CurrentChain or #self.CurrentChain == 0 then
		return false
	end

	self.CurrentChainIndex = self.CurrentChainIndex + 1

	-- If we've reached the end of the chain, choose a new one
	if self.CurrentChainIndex > #self.CurrentChain then
		if self.Config.DebugPrints then
			print(self.Character.Name .. " completed chain, choosing new one")
		end
		self:ChooseNewChain()
		return true
	end

	if self.Config.DebugPrints then
		print(self.Character.Name .. " advancing to waypoint " .. self.CurrentChainIndex .. " of " .. #self.CurrentChain)
	end

	return true
end

function NPC:CreateFallbackWaypoints()
	-- Create waypoints around the NPC's spawn position
	local center = self.OriginalPosition
	self.FallbackWaypoints = {
		center + Vector3.new(20, 0, 0),
		center + Vector3.new(0, 0, 20),
		center + Vector3.new(-20, 0, 0),
		center + Vector3.new(0, 0, -20),
		center + Vector3.new(15, 0, 15),
		center + Vector3.new(-15, 0, 15),
		center + Vector3.new(-15, 0, -15),
		center + Vector3.new(15, 0, -15)
	}

	-- Create a simple chain from fallback waypoints
	self.CurrentChain = {}
	for i, pos in ipairs(self.FallbackWaypoints) do
		-- Create fake parts for consistency
		local fakePart = {Position = pos, Name = "Fallback" .. i}
		table.insert(self.CurrentChain, fakePart)
	end
	self.CurrentChainIndex = 1
end

function NPC:SetupInjuryDetection()
	-- Detect when NPC takes damage
	self.Humanoid.HealthChanged:Connect(function(health)
		if health < self.Humanoid.MaxHealth then
			self:OnInjured()
		end
	end)

	-- Also detect when hit by tools/weapons
	self.Character.ChildAdded:Connect(function(child)
		if child:IsA("Tool") then
			self:OnInjured()
		end
	end)

	-- Prevent teleporting when hurt
	if self.Config.PreventTeleporting then
		self.Humanoid.PlatformStand = false

		-- Monitor for unwanted position changes
		spawn(function()
			while self.Character and self.Character.Parent do
				local currentPos = self.RootPart.Position
				local expectedMaxDistance = 50 -- Maximum reasonable distance the NPC should move in one frame

				if (currentPos - self.OriginalPosition).Magnitude > expectedMaxDistance * 3 then
					-- If NPC has moved too far from original position unexpectedly, check if it's falling
					if self.RootPart.Velocity.Y < -50 then
						-- NPC is falling too fast, likely teleported upward, restore position
						self.RootPart.CFrame = CFrame.new(self.OriginalPosition + Vector3.new(0, 5, 0))
						self.RootPart.Velocity = Vector3.new(0, 0, 0)

						if self.Config.DebugPrints then
							print("Prevented " .. self.Character.Name .. " from teleporting/falling")
						end
					end
				end

				wait(0.1)
			end
		end)
	end
end

function NPC:OnInjured()
	-- Don't flee if already fleeing or at work (unless severely threatened)
	if self.State == "Fleeing" then return end

	-- If at work, require more damage to flee
	if self.State == "Working" or self.State == "GoingToWork" then
		if self.Humanoid.Health > self.Humanoid.MaxHealth * 0.7 then
			return -- Don't flee from work unless significantly hurt
		end
	end

	-- Store current state before fleeing
	if self.State == "Working" or self.State == "GoingToWork" or self.State == "LeavingWork" then
		-- Remember work state to return to it later
		self.PreFleeState = self.State
		self.PreFleeJob = self.CurrentJob
	else
		self.PreFleeChain = self.CurrentChain
		self.PreFleeChainIndex = self.CurrentChainIndex
	end

	-- Find the closest player as the threat
	local closestPlayer = self:FindClosestPlayer()
	if closestPlayer then
		-- Remember this player as a threat
		self:RememberThreat(closestPlayer)

		self.ThreatPlayer = closestPlayer
		self.State = "Fleeing"
		self.FleeStartTime = tick()
		self.Humanoid.WalkSpeed = self.Config.RunSpeed

		if self.Config.DebugPrints then
			print(self.Character.Name .. " is fleeing from work/wandering")
		end
	end
end

function NPC:FindClosestPlayer()
	local closestPlayer = nil
	local closestDistance = math.huge

	for _, player in pairs(Players:GetPlayers()) do
		if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
			local distance = (player.Character.HumanoidRootPart.Position - self.RootPart.Position).Magnitude
			if distance < closestDistance then
				closestDistance = distance
				closestPlayer = player
			end
		end
	end

	return closestPlayer
end

function NPC:RememberThreat(player)
	local playerName = player.Name
	if not self.RememberedThreats[playerName] then
		self.RememberedThreats[playerName] = {
			lastSeen = tick(),
			dangerLevel = 1,
			player = player
		}
	else
		-- Increase danger level for repeat offenders
		self.RememberedThreats[playerName].dangerLevel = self.RememberedThreats[playerName].dangerLevel + 1
		self.RememberedThreats[playerName].lastSeen = tick()
		self.RememberedThreats[playerName].player = player
	end

	if self.Config.DebugPrints then
		print(self.Character.Name .. " now remembers " .. playerName .. " as a threat (Danger Level: " .. 
			self.RememberedThreats[playerName].dangerLevel .. ")")
	end
end

function NPC:ForgetOldThreats()
	local currentTime = tick()
	for playerName, threatData in pairs(self.RememberedThreats) do
		if currentTime - threatData.lastSeen > self.Config.MemoryDuration then
			if self.Config.DebugPrints then
				print(self.Character.Name .. " has forgotten about " .. playerName)
			end
			self.RememberedThreats[playerName] = nil
		end
	end
end

function NPC:GetNearbyThreats()
	local nearbyThreats = {}

	for playerName, threatData in pairs(self.RememberedThreats) do
		if threatData.player and threatData.player.Character and 
			threatData.player.Character:FindFirstChild("HumanoidRootPart") then

			local distance = (threatData.player.Character.HumanoidRootPart.Position - self.RootPart.Position).Magnitude
			if distance <= self.Config.AvoidanceDistance then
				table.insert(nearbyThreats, {
					player = threatData.player,
					distance = distance,
					dangerLevel = threatData.dangerLevel,
					position = threatData.player.Character.HumanoidRootPart.Position
				})
			end
		end
	end

	return nearbyThreats
end

function NPC:GetAvoidanceAdjustedDestination(originalDestination)
	local threats = self:GetNearbyThreats()
	if #threats == 0 then
		return originalDestination
	end

	local avoidanceVector = Vector3.new(0, 0, 0)
	local myPos = self.RootPart.Position
	local fleeDirection = (myPos - threatPos).Unit

	-- Flee further away from players with higher danger levels
	local dangerMultiplier = 1
	if self.RememberedThreats[self.ThreatPlayer.Name] then
		dangerMultiplier = self.RememberedThreats[self.ThreatPlayer.Name].dangerLevel
	end

	local fleeDistance = self.Config.FleeDistance * dangerMultiplier
	return myPos + fleeDirection * fleeDistance
end

function NPC:CreatePath(destination)
	local path = PathfindingService:CreatePath(self.PathfindingAgent)
	local success, errorMessage = pcall(function()
		path:ComputeAsync(self.RootPart.Position, destination)
	end)

	if success and path.Status == Enum.PathStatus.Success then
		return path
	else
		if self.Config.DebugPrints then
			warn("Path creation failed for " .. self.Character.Name .. ": " .. tostring(errorMessage))
		end
		return nil
	end
end

function NPC:FollowPath(path)
	if not path then return end

	local waypoints = path:GetWaypoints()
	if #waypoints < 2 then return end

	self.Humanoid:MoveTo(waypoints[2].Position) -- Skip first waypoint (current position)

	-- Handle waypoint reached
	local connection
	connection = self.Humanoid.MoveToFinished:Connect(function(reached)
		if reached and #waypoints > 2 then
			table.remove(waypoints, 1)
			if #waypoints > 1 then
				self.Humanoid:MoveTo(waypoints[2].Position)
			else
				connection:Disconnect()
				-- Check if we've reached our target waypoint in the chain
				self:CheckWaypointReached()
			end
		else
			connection:Disconnect()
			-- Check if we've reached our target waypoint in the chain
			self:CheckWaypointReached()
		end
	end)
end

function NPC:CheckWaypointReached()
	local currentTarget = self:GetCurrentWaypointInChain()
	local distanceToTarget = (self.RootPart.Position - currentTarget).Magnitude

	if distanceToTarget <= self.Config.WaypointTolerance then
		-- We've reached the current waypoint in the chain, advance to next
		self:AdvanceInChain()
	end
end

function NPC:GetNextWaypoint()
	-- Get the current waypoint from the chain
	return self:GetCurrentWaypointInChain()
end

function NPC:FindClosestWaypointInChain(chain)
	if not chain or #chain == 0 then
		return 1
	end

	local closestIndex = 1
	local closestDistance = math.huge
	local myPos = self.RootPart.Position

	for i, waypoint in ipairs(chain) do
		local distance = (myPos - waypoint.Position).Magnitude
		if distance < closestDistance then
			closestDistance = distance
			closestIndex = i
		end
	end

	return closestIndex
end

function NPC:UpdateWandering()
	-- Clean up old threat memories
	self:ForgetOldThreats()

	local currentTime = tick()
	if currentTime - self.LastPathUpdate > self.Config.PathUpdateInterval then
		local destination = self:GetNextWaypoint()

		-- Adjust destination to avoid remembered threats
		destination = self:GetAvoidanceAdjustedDestination(destination)

		local path = self:CreatePath(destination)
		if path then
			self:FollowPath(path)
		else
			-- Fallback: direct movement
			self.Humanoid:MoveTo(destination)
		end
		self.LastPathUpdate = currentTime
	end
end

function NPC:UpdateFleeing()
	local currentTime = tick()

	-- Check if we should stop fleeing
	if self.ThreatPlayer and self.ThreatPlayer.Character and self.ThreatPlayer.Character:FindFirstChild("HumanoidRootPart") then
		local distance = (self.ThreatPlayer.Character.HumanoidRootPart.Position - self.RootPart.Position).Magnitude
		if distance > self.Config.FleeDistance * 1.5 or currentTime - self.FleeStartTime > 10 then
			self.State = "Returning"
			self.Humanoid.WalkSpeed = self.Config.WalkSpeed
			return
		end
	else
		self.State = "Returning"
		self.Humanoid.WalkSpeed = self.Config.WalkSpeed
		return
	end

	-- Continue fleeing
	if currentTime - self.LastPathUpdate > 1 then -- Update flee path more frequently
		local fleeDestination = self:GetFleeDestination()
		local path = self:CreatePath(fleeDestination)
		if path then
			self:FollowPath(path)
		else
			self.Humanoid:MoveTo(fleeDestination)
		end
		self.LastPathUpdate = currentTime
	end
end

function NPC:UpdateReturning()
	-- Determine what to return to based on what we were doing before fleeing
	local returnDestination

	if self.PreFleeState and (self.PreFleeState == "Working" or self.PreFleeState == "GoingToWork") then
		-- Return to work if we were working
		if self.PreFleeJob then
			returnDestination = self:GetJobSitePosition()
		else
			returnDestination = self.OriginalPosition
		end
	elseif self.PreFleeChain and #self.PreFleeChain > 0 then
		-- Return to wandering
		local closestIndex = self:FindClosestWaypointInChain(self.PreFleeChain)
		returnDestination = self.PreFleeChain[closestIndex].Position
	else
		-- Fallback to original position
		returnDestination = self.OriginalPosition
	end

	local distanceToReturn = (self.RootPart.Position - returnDestination).Magnitude

	if distanceToReturn < self.Config.WaypointTolerance then
		-- Arrived back, restore previous state
		wait(self.Config.ReturnDelay)

		if self.PreFleeState and (self.PreFleeState == "Working" or self.PreFleeState == "GoingToWork") then
			-- Resume work
			self.State = self.PreFleeState
			self.CurrentJob = self.PreFleeJob
		elseif self.PreFleeChain and #self.PreFleeChain > 0 then
			-- Resume wandering
			self.CurrentChain = self.PreFleeChain
			self.CurrentChainIndex = self:FindClosestWaypointInChain(self.PreFleeChain)
			self.State = "Wandering"
		else
			self.State = "Wandering"
		end

		-- Clean up flee state
		self.ThreatPlayer = nil
		self.PreFleeChain = nil
		self.PreFleeChainIndex = 1
		self.PreFleeState = nil
		self.PreFleeJob = nil
		self.Humanoid.Health = self.Humanoid.MaxHealth -- Heal the NPC

		if self.Config.DebugPrints then
			print(self.Character.Name .. " returned from fleeing")
		end
	else
		-- Path back to the return destination
		local currentTime = tick()
		if currentTime - self.LastPathUpdate > self.Config.PathUpdateInterval then
			local path = self:CreatePath(returnDestination)
			if path then
				self:FollowPath(path)
			else
				self.Humanoid:MoveTo(returnDestination)
			end
			self.LastPathUpdate = currentTime
		end
	end
end

function NPC:StartMainLoop()
	spawn(function()
		while self.Character and self.Character.Parent and self.Humanoid and self.RootPart do
			if self.State == "Wandering" then
				self:UpdateWandering()
			elseif self.State == "Fleeing" then
				self:UpdateFleeing()
			elseif self.State == "Returning" then
				self:UpdateReturning()
			elseif self.State == "GoingToWork" then
				self:UpdateGoingToWork()
			elseif self.State == "Working" then
				self:UpdateWorking()
			elseif self.State == "LeavingWork" then
				self:UpdateLeavingWork()
			end

			wait(0.1) -- Update frequency
		end
	end)
end

-- Global time system instance
local GlobalTimeSystem = TimeSystem.new(NPC_CONFIG)

-- Initialize the NPC with job scheduling
local function InitializeNPC()
	-- Wait a moment for the character to fully load
	wait(1)

	-- Find the character this script belongs to
	local character = nil

	-- Check if script is inside a model (the NPC)
	local parent = script.Parent
	while parent do
		if parent:IsA("Model") and parent:FindFirstChild("Humanoid") and parent:FindFirstChild("HumanoidRootPart") then
			character = parent
			break
		end
		parent = parent.Parent
	end

	-- If we couldn't find the character from the script's parent hierarchy,
	-- try to find it in workspace
	if not character then
		if NPC_CONFIG.DebugPrints then
			warn("Could not find NPC character from script location. Make sure this script is inside an NPC model.")
		end
		return
	end

	-- Create the NPC behavior with time system
	local npc = NPC.new(character, NPC_CONFIG, GlobalTimeSystem)
	if npc then
		-- Example job schedules - customize these for each NPC
		-- You can add different jobs for different NPCs by checking character.Name

		if character.Name == "Worker1" then
			-- Work at "Factory" from 9:00 AM to 5:00 PM (8 hours = 480 minutes)
			npc:AddJobSchedule("Factory", 9, 0, 480)
		elseif character.Name == "ShopKeeper" then
			-- Work at "Shop" from 8:00 AM to 6:00 PM (10 hours = 600 minutes)
			npc:AddJobSchedule("Shop", 8, 0, 600)
		elseif character.Name == "NightGuard" then
			-- Work at "Security" from 10:00 PM to 6:00 AM (8 hours = 480 minutes)
			npc:AddJobSchedule("Security", 22, 0, 480)
		else
			-- Default job - work at "Office" from 9:00 AM to 5:00 PM
			npc:AddJobSchedule("Office", 9, 0, 480)
		end

		if NPC_CONFIG.DebugPrints then
			print("Successfully initialized NPC behavior with time system for " .. character.Name)
			print("Current time: " .. GlobalTimeSystem:GetTimeString())
		end
	else
		if NPC_CONFIG.DebugPrints then
			warn("Failed to initialize NPC behavior for " .. character.Name)
		end
	end
end

-- Create a GUI to display the current time (optional)
local function CreateTimeDisplay()
	local Players = game:GetService("Players")
	local player = Players.LocalPlayer

	if not player then return end

	local playerGui = player:WaitForChild("PlayerGui")

	-- Create ScreenGui
	local screenGui = Instance.new("ScreenGui")
	screenGui.Name = "TimeDisplay"
	screenGui.Parent = playerGui

	-- Create Frame
	local frame = Instance.new("Frame")
	frame.Size = UDim2.new(0, 200, 0, 50)
	frame.Position = UDim2.new(0, 10, 0, 10)
	frame.BackgroundColor3 = Color3.new(0, 0, 0)
	frame.BackgroundTransparency = 0.3
	frame.BorderSizePixel = 0
	frame.Parent = screenGui

	-- Create TextLabel
	local timeLabel = Instance.new("TextLabel")
	timeLabel.Size = UDim2.new(1, 0, 1, 0)
	timeLabel.Position = UDim2.new(0, 0, 0, 0)
	timeLabel.BackgroundTransparency = 1
	timeLabel.Text = "Time: " .. GlobalTimeSystem:GetTimeString()
	timeLabel.TextColor3 = Color3.new(1, 1, 1)
	timeLabel.TextScaled = true
	timeLabel.Font = Enum.Font.SourceSansBold
	timeLabel.Parent = frame

	-- Update the time display
	spawn(function()
		while screenGui and screenGui.Parent do
			timeLabel.Text = "Time: " .. GlobalTimeSystem:GetTimeString()
			wait(1)
		end
	end)
end

-- Start the NPC initialization
spawn(InitializeNPC)

-- Create time display if this is running on the client
if game:GetService("RunService"):IsClient() then
	spawn(CreateTimeDisplay)
end.RootPart.Position

-- Calculate avoidance vector based on all nearby threats
for _, threat in ipairs(threats) do
	local threatPos = threat.position
	local directionAway = (myPos - threatPos).Unit
	local influence = (self.Config.AvoidanceDistance - threat.distance) / self.Config.AvoidanceDistance
	influence = influence * threat.dangerLevel * self.Config.AvoidanceStrength

	avoidanceVector = avoidanceVector + (directionAway * influence * 20)
end

-- Apply avoidance to destination
local adjustedDestination = originalDestination + avoidanceVector

-- Make sure the adjusted destination is still reasonable (not too far off course)
local maxDeviation = 30
local deviation = (adjustedDestination - originalDestination).Magnitude
if deviation > maxDeviation then
	local deviationDirection = (adjustedDestination - originalDestination).Unit
	adjustedDestination = originalDestination + (deviationDirection * maxDeviation)
end

return adjustedDestination
end

function NPC:GetFleeDestination()
	if not self.ThreatPlayer or not self.ThreatPlayer.Character then
		return self.OriginalPosition
	end

	local threatPos = self.ThreatPlayer.Character.HumanoidRootPart.Position
	local myPos = self
